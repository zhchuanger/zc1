<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // var person1 = {
        //     name :"zs",
        //     age: 10,
        //     eat: function () {
        //         console.log("哈哈");
        //     }
        // }
        // person1.eat();
        // console.log(person1.name);
        // 类具有相同属性和方法的对象的集合  属性构造函数中  方法写在原型下
        function Person(name, age) {//构造函数
            this.name = name;
            this.age = age;

        }
        Person.prototype.play = function () {
            console.log(this.name + "哈哈！");
        }


        //实例化  具体对象

        var person1 = new Person("zs", 20);
        console.log(person1);

        var person2 = new Person("lisi", 30);
        console.log(person2);

        person2.play();

        //prototype 原型 非常重要!!! 构造函数有一个prototype属性  
        //属性指向原型对象（原型对象下有一个constructor属性指向构造函数）  声明在原型对象下的属性和方法可以被所有实例化的对象可共享
        //__proto__ 实例对象下的属性指向构造函数下的原型对象



        // console.log(person1.__proto__   ===  person2.__proto__);

        /*
            原型链
            当从一个对象那里调取属性或方法时，如果该对象自身不存在这样的属性或方法，
            就会去自己关联的prototype对象那里寻找，如果prototype没有，
            就会去prototype关联的前辈prototype那里寻找，
            如果再没有则继续查找Prototype.Prototype引用的对象，
            依次类推，直到Prototype.….Prototype为undefined
            （Object的Prototype就是undefined）从而形成了所谓的“原型链”。
        */




    </script>
</body>

</html>